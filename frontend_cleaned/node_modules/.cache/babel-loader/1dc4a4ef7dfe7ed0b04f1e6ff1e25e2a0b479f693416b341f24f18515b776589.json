{"ast":null,"code":"// src/api/axiosInstance.ts\nimport axios from \"axios\";\nconst API_BASE = process.env.REACT_APP_API_BASE || \"http://localhost:4000/api\";\nconst instance = axios.create({\n  baseURL: API_BASE,\n  withCredentials: true\n});\n\n// localStorage token key used by the rest of the app\nconst TOKEN_KEY = \"token\";\nconst getAccessToken = () => localStorage.getItem(TOKEN_KEY);\nconst setAccessToken = t => localStorage.setItem(TOKEN_KEY, t);\nconst clearAuth = () => {\n  localStorage.removeItem(TOKEN_KEY);\n  // optional: redirect to login root\n  window.location.href = \"/\";\n};\nlet isRefreshing = false;\nlet failedQueue = [];\nconst processQueue = async (error, token = null) => {\n  for (const prom of failedQueue) {\n    if (error) {\n      prom.reject(error);\n    } else {\n      if (token) {\n        prom.config.headers = prom.config.headers || {};\n        prom.config.headers.Authorization = `Bearer ${token}`;\n      }\n      try {\n        const response = await instance(prom.config);\n        prom.resolve(response);\n      } catch (err) {\n        prom.reject(err);\n      }\n    }\n  }\n  failedQueue = [];\n};\ninstance.interceptors.request.use(config => {\n  const token = getAccessToken();\n  if (token && config.headers) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n  return config;\n});\ninstance.interceptors.response.use(response => response, async error => {\n  var _error$response, _originalConfig$url;\n  const originalConfig = error.config;\n  if (!originalConfig) return Promise.reject(error);\n\n  // If not 401, just forward\n  if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) !== 401) {\n    return Promise.reject(error);\n  }\n\n  // If refresh endpoint itself failed -> logout\n  if ((_originalConfig$url = originalConfig.url) !== null && _originalConfig$url !== void 0 && _originalConfig$url.includes(\"/auth/refresh\")) {\n    clearAuth();\n    return Promise.reject(error);\n  }\n\n  // If already refreshing, queue the request\n  if (isRefreshing) {\n    return new Promise((resolve, reject) => {\n      failedQueue.push({\n        resolve,\n        reject,\n        config: originalConfig\n      });\n    });\n  }\n  isRefreshing = true;\n  try {\n    var _resp$data;\n    // call refresh endpoint on backend. Ensure backend issues new token and sets cookie if needed.\n    const resp = await axios.post(`${API_BASE}/auth/refresh`, {}, {\n      withCredentials: true\n    });\n    const newToken = (_resp$data = resp.data) === null || _resp$data === void 0 ? void 0 : _resp$data.token;\n    if (!newToken) throw new Error(\"No token in refresh response\");\n    setAccessToken(newToken);\n\n    // attach to original request\n    originalConfig.headers = originalConfig.headers || {};\n    originalConfig.headers.Authorization = `Bearer ${newToken}`;\n    processQueue(null, newToken);\n    return instance(originalConfig);\n  } catch (refreshErr) {\n    processQueue(refreshErr, null);\n    clearAuth();\n    return Promise.reject(refreshErr);\n  } finally {\n    isRefreshing = false;\n  }\n});\nexport default instance;","map":{"version":3,"names":["axios","API_BASE","process","env","REACT_APP_API_BASE","instance","create","baseURL","withCredentials","TOKEN_KEY","getAccessToken","localStorage","getItem","setAccessToken","t","setItem","clearAuth","removeItem","window","location","href","isRefreshing","failedQueue","processQueue","error","token","prom","reject","config","headers","Authorization","response","resolve","err","interceptors","request","use","_error$response","_originalConfig$url","originalConfig","Promise","status","url","includes","push","_resp$data","resp","post","newToken","data","Error","refreshErr"],"sources":["C:/Users/admin/Desktop/chatbot/frontend_cleaned/src/api/axiosInstance.ts"],"sourcesContent":["// src/api/axiosInstance.ts\r\nimport axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from \"axios\";\r\n\r\nconst API_BASE = process.env.REACT_APP_API_BASE || \"http://localhost:4000/api\";\r\n\r\ninterface FailedQueueItem {\r\n  resolve: (value?: AxiosResponse) => void;\r\n  reject: (err: any) => void;\r\n  config: AxiosRequestConfig;\r\n}\r\n\r\nconst instance = axios.create({\r\n  baseURL: API_BASE,\r\n  withCredentials: true,\r\n});\r\n\r\n// localStorage token key used by the rest of the app\r\nconst TOKEN_KEY = \"token\";\r\nconst getAccessToken = () => localStorage.getItem(TOKEN_KEY);\r\nconst setAccessToken = (t: string) => localStorage.setItem(TOKEN_KEY, t);\r\nconst clearAuth = () => {\r\n  localStorage.removeItem(TOKEN_KEY);\r\n  // optional: redirect to login root\r\n  window.location.href = \"/\";\r\n};\r\n\r\nlet isRefreshing = false;\r\nlet failedQueue: FailedQueueItem[] = [];\r\n\r\nconst processQueue = async (error: any, token: string | null = null) => {\r\n  for (const prom of failedQueue) {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      if (token) {\r\n        prom.config.headers = prom.config.headers || {};\r\n        (prom.config.headers as any).Authorization = `Bearer ${token}`;\r\n      }\r\n      try {\r\n        const response = await instance(prom.config);\r\n        prom.resolve(response);\r\n      } catch (err) {\r\n        prom.reject(err);\r\n      }\r\n    }\r\n  }\r\n  failedQueue = [];\r\n};\r\n\r\ninstance.interceptors.request.use((config) => {\r\n  const token = getAccessToken();\r\n  if (token && config.headers) {\r\n    (config.headers as any).Authorization = `Bearer ${token}`;\r\n  }\r\n  return config;\r\n});\r\n\r\ninstance.interceptors.response.use(\r\n  (response) => response,\r\n  async (error: AxiosError & { config?: AxiosRequestConfig }) => {\r\n    const originalConfig = error.config;\r\n    if (!originalConfig) return Promise.reject(error);\r\n\r\n    // If not 401, just forward\r\n    if (error.response?.status !== 401) {\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    // If refresh endpoint itself failed -> logout\r\n    if (originalConfig.url?.includes(\"/auth/refresh\")) {\r\n      clearAuth();\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    // If already refreshing, queue the request\r\n    if (isRefreshing) {\r\n      return new Promise((resolve, reject) => {\r\n        failedQueue.push({ resolve, reject, config: originalConfig });\r\n      });\r\n    }\r\n\r\n    isRefreshing = true;\r\n    try {\r\n      // call refresh endpoint on backend. Ensure backend issues new token and sets cookie if needed.\r\n      const resp = await axios.post(`${API_BASE}/auth/refresh`, {}, { withCredentials: true });\r\n      const newToken = resp.data?.token;\r\n      if (!newToken) throw new Error(\"No token in refresh response\");\r\n      setAccessToken(newToken);\r\n\r\n      // attach to original request\r\n      originalConfig.headers = originalConfig.headers || {};\r\n      (originalConfig.headers as any).Authorization = `Bearer ${newToken}`;\r\n\r\n      processQueue(null, newToken);\r\n      return instance(originalConfig);\r\n    } catch (refreshErr) {\r\n      processQueue(refreshErr, null);\r\n      clearAuth();\r\n      return Promise.reject(refreshErr);\r\n    } finally {\r\n      isRefreshing = false;\r\n    }\r\n  }\r\n);\r\n\r\nexport default instance;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}